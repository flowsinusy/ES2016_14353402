# LAB4
## 产生死锁的必要条件
1.互斥：一个资源每次只能被一个进程所使用；<br/>
2.占有并等待：一个进程由于请求资源被阻塞，且持有其它资源不放；<br/>
3.非抢占：进程已经持有的资源，在使用完主动放弃之前，不能被强占；<br/>
4.无限等待：若干进程之间形成一种首尾相接的循环等待资源的关系。

## 程序产生死锁的分析
对于A类和B类，它们的两种方法method和last都使用了关键字synchronized，表明在同一时刻，最多只有一个线程执行该段代码。满足互斥的条件。<br/>
当线程t调用了start方法后，t被插入到调度队列里，当调度到它的时候，运行run里的方法。<br/>
首先主线程等待了20000，线程t先被调度，也许整个程序运行在某一个时间点时，t执行b.methodB(a)，然后要进入a.last方法，但还没来得及，此时主线程执行a.methodA(b)，要进入b.last方法，这样t持有b的method方法等待a的last方法，主线程持有a的method方法等待b的last方法，两个线程都占有并等待，并且形成首尾相接的无限等待，在非抢占的情况下，即形成死锁。

## 死锁截图
count值为20000时<br/>
![死锁1][1]

  [1]: ./images/deadlock1.jpg "deadlock1.jpg"
